/**
 * This file is part of Graylog.
 *
 * Graylog is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Graylog is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Graylog.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.graylog2.shared.security.tls;

import org.apache.commons.io.IOUtils;
import org.bouncycastle.asn1.ASN1InputStream;
import org.bouncycastle.asn1.ASN1Sequence;
import org.bouncycastle.asn1.x509.AlgorithmIdentifier;
import org.bouncycastle.asn1.x509.BasicConstraints;
import org.bouncycastle.asn1.x509.Extension;
import org.bouncycastle.asn1.x509.SubjectKeyIdentifier;
import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;
import org.bouncycastle.asn1.x500.X500Name;
import org.bouncycastle.cert.bc.BcX509ExtensionUtils;
import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter;
import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
import org.bouncycastle.crypto.util.PrivateKeyFactory;
import org.bouncycastle.jce.X509KeyUsage;
import org.bouncycastle.operator.ContentSigner;
import org.bouncycastle.operator.DefaultDigestAlgorithmIdentifierFinder;
import org.bouncycastle.operator.DefaultSignatureAlgorithmIdentifierFinder;
import org.bouncycastle.operator.bc.BcRSAContentSignerBuilder;
import org.bouncycastle.cert.X509v3CertificateBuilder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.math.BigInteger;
import java.security.GeneralSecurityException;
import java.security.Key;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.KeyStore;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.SecureRandom;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.Date;

import static com.google.common.base.Strings.isNullOrEmpty;
import static java.util.Objects.requireNonNull;

/**
 * Generates a temporary self-signed certificate for testing purposes.
 * <p>
 * <strong>NOTE:</strong>
 * Never use the certificate and private key generated by this class in production.
 * It is purely for testing purposes, and thus it is very insecure.
 * It even uses an insecure pseudo-random generator for faster generation internally.
 * </p>
 */
public final class SelfSignedCertificate {
    private static final Logger LOG = LoggerFactory.getLogger(SelfSignedCertificate.class);

    /**
     * Current time minus 1 year, just in case software clock goes back due to time synchronization
     */
    static final Date NOT_BEFORE = new Date(System.currentTimeMillis() - 86400000L * 365);
    /**
     * The maximum possible value in X.509 specification: 9999-12-31 23:59:59
     */
    static final Date NOT_AFTER = new Date(253402300799000L);

    private final Certificate certificate;
    private final PrivateKey privateKey;
    private final KeyStore keyStore;

    private SelfSignedCertificate(PrivateKey privateKey, Certificate certificate, KeyStore keyStore) throws CertificateException {
        this.privateKey = requireNonNull(privateKey);
        this.certificate = requireNonNull(certificate);
        this.keyStore = requireNonNull(keyStore);
    }

    /**
     * Returns the generated X.509 certificate.
     */
    public Certificate certificate() {
        return certificate;
    }

    /**
     * Returns the generated RSA private key.
     */
    public PrivateKey privateKey() {
        return privateKey;
    }

    /**
     * Returns the key store with the generated RSA private key and the X.509 certificate.
     */
    public KeyStore keyStore() {
        return keyStore;
    }

    /**
     * Creates a new instance with FQDN "example.com".
     */
    public static SelfSignedCertificate create() throws GeneralSecurityException, IOException {
        return create("example.com", "password");
    }

    /**
     * Creates a new instance with a key length of 1024 bits.
     *
     * Bypass entropy collection by using insecure random generator.
     * We just want to generate it without any delay because it's for testing purposes only.
     *
     * @param fqdn     a fully qualified domain name
     * @param password the password for the generated key store
     */
    public static SelfSignedCertificate create(String fqdn, String password) throws GeneralSecurityException, IOException {
        return create(fqdn, ThreadLocalInsecureRandom.current(), 1024, password);
    }

    /**
     * Creates a new instance.
     *
     * @param fqdn     a fully qualified domain name
     * @param random   the {@link SecureRandom} to use
     * @param bits     the number of bits of the generated private key
     * @param password the password for the generated key store
     */
    public static SelfSignedCertificate create(String fqdn, SecureRandom random, int bits, String password) throws GeneralSecurityException, IOException {
        if (isNullOrEmpty(fqdn)) {
            throw new IllegalArgumentException("FQDN must not be empty");
        }
        if (isNullOrEmpty(password)) {
            throw new IllegalArgumentException("Key store password must not be empty");
        }

        final KeyPair keypair = generateKeyPair(random, bits);
        final PrivateKey privateKey = keypair.getPrivate();
        final X509Certificate certificate;

        try {
            certificate = generateCertificate(fqdn, keypair, random);
        } catch (Throwable t) {
            LOG.debug("Failed to generate a self-signed X.509 certificate using X509v3CertificateBuilder:", t);

            throw new CertificateException("No provider succeeded to generate a self-signed certificate. See debug log for the root cause.");
        }

        final KeyStore keyStore = generateKeyStore(fqdn, privateKey, certificate, password);

        return new SelfSignedCertificate(privateKey, certificate, keyStore);
    }

    private static KeyPair generateKeyPair(SecureRandom random, int bits) {
        final KeyPair keypair;
        try {
            KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
            keyGen.initialize(bits, random);
            keypair = keyGen.generateKeyPair();
        } catch (NoSuchAlgorithmException e) {
            // Should not reach here because every Java implementation must have RSA key pair generator.
            throw new Error(e);
        }
        return keypair;
    }

    private static SubjectKeyIdentifier createSubjectKeyIdentifier(Key publicKey) throws IOException {
        try (ASN1InputStream is = new ASN1InputStream(new ByteArrayInputStream(publicKey.getEncoded()))) {
            ASN1Sequence seq = (ASN1Sequence) is.readObject();
            SubjectPublicKeyInfo info = new SubjectPublicKeyInfo(seq);
            return new BcX509ExtensionUtils().createSubjectKeyIdentifier(info);
        }
    }

    private static X509Certificate generateCertificate(String fqdn, KeyPair keypair, SecureRandom random) throws Exception {
        final X500Name subject = new X500Name("CN=" + fqdn);
        final SubjectPublicKeyInfo subPubKeyInfo = SubjectPublicKeyInfo.getInstance(keypair.getPublic().getEncoded());
        final AlgorithmIdentifier sigAlgId = new DefaultSignatureAlgorithmIdentifierFinder().find("SHA1withRSA");
        final AlgorithmIdentifier digAlgId = new DefaultDigestAlgorithmIdentifierFinder().find(sigAlgId);
        final AsymmetricKeyParameter keyParam = PrivateKeyFactory.createKey(keypair.getPrivate().getEncoded());
        final ContentSigner sigGen = new BcRSAContentSignerBuilder(sigAlgId, digAlgId).build(keyParam);

        X509v3CertificateBuilder v3CertBuilder = new X509v3CertificateBuilder(subject,
            new BigInteger(64, random),
            NOT_BEFORE,
            NOT_AFTER,
            subject,
            subPubKeyInfo);

        v3CertBuilder.addExtension(Extension.basicConstraints,
            true,
            new BasicConstraints(true));
        v3CertBuilder.addExtension(Extension.keyUsage,
            true,
            new X509KeyUsage(X509KeyUsage.digitalSignature |
                X509KeyUsage.nonRepudiation |
                X509KeyUsage.keyEncipherment |
                X509KeyUsage.dataEncipherment));
        v3CertBuilder.addExtension(Extension.subjectKeyIdentifier,
            false,
            createSubjectKeyIdentifier(keypair.getPublic()));

        JcaX509CertificateConverter converter = new JcaX509CertificateConverter();
        X509Certificate cert = converter.getCertificate(v3CertBuilder.build(sigGen));

        cert.checkValidity();
        cert.verify(keypair.getPublic());

        return cert;
    }

    private static KeyStore generateKeyStore(String fqdn,
                                             PrivateKey privateKey,
                                             Certificate certificate,
                                             String password) throws GeneralSecurityException, IOException {
        final KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());

        // Initialize key store
        keyStore.load(null, password.toCharArray());

        keyStore.setKeyEntry(fqdn, privateKey, password.toCharArray(), new Certificate[]{certificate});

        return keyStore;
    }
}
