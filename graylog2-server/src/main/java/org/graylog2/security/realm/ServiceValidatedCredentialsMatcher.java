/*
 * Copyright (C) 2020 Graylog, Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the Server Side Public License, version 1,
 * as published by MongoDB, Inc.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * Server Side Public License for more details.
 *
 * You should have received a copy of the Server Side Public License
 * along with this program. If not, see
 * <http://www.mongodb.com/licensing/server-side-public-license>.
 */
package org.graylog2.security.realm;

import org.apache.shiro.authc.AuthenticationInfo;
import org.apache.shiro.authc.AuthenticationToken;
import org.apache.shiro.authc.credential.CredentialsMatcher;

/**
 * A {@link CredentialsMatcher} for realms that perform credential validation internally within
 * {@code doGetAuthenticationInfo} rather than delegating it to Shiro's credential matching infrastructure.
 *
 * <h2>Background</h2>
 * <p>Several Graylog realms (e.g., access token, session, bearer token, username/password) validate credentials
 * against external services or stores during {@code doGetAuthenticationInfo}. On success, they return a
 * {@link org.apache.shiro.authc.SimpleAccount} with the {@link #AUTHENTICATED} sentinel as credentials,
 * signaling that validation has already occurred and there is nothing left for Shiro to verify. Previously
 * these realms used {@link org.apache.shiro.authc.credential.AllowAllCredentialsMatcher}, which unconditionally
 * returned {@code true}.</p>
 *
 * <h2>Problem with Shiro 2.1.0</h2>
 * <p>Shiro 2.1.0 introduced a timing attack mitigation for CVE-2026-23901. When {@code doGetAuthenticationInfo}
 * returns {@code null} (user not found or authentication not applicable), {@code AuthenticatingRealm.getAuthenticationInfo}
 * now calls {@code simulateFailedLogin}, which runs the configured {@code CredentialsMatcher} against a
 * synthetic {@code AuthenticationInfo} containing non-null dummy credentials. If the matcher accepts the simulated
 * credentials, Shiro considers this a misconfiguration and throws an
 * {@link org.apache.shiro.authc.IncorrectCredentialsException}.</p>
 *
 * <p>{@code AllowAllCredentialsMatcher} always returns {@code true}, so it invariably trips this check, breaking
 * all realms that use it.</p>
 *
 * <h2>How this matcher fixes it</h2>
 * <p>This matcher uses an identity check against the {@link #AUTHENTICATED} sentinel object. Realms that have
 * successfully validated credentials set this sentinel as the credential in their {@code SimpleAccount}:</p>
 * <pre>
 * new SimpleAccount(userId, ServiceValidatedCredentialsMatcher.AUTHENTICATED, realmName);
 * </pre>
 * <ul>
 *   <li><b>Real authentication:</b> credentials are the {@link #AUTHENTICATED} sentinel (identity match) &rarr;
 *   returns {@code true}.</li>
 *   <li><b>Simulated failed login:</b> credentials are dummy values generated by Shiro, which can never be the
 *   same object instance &rarr; returns {@code false}, which is the expected outcome and prevents the
 *   misconfiguration exception.</li>
 * </ul>
 *
 * <p>Because {@code simulateFailedLogin} and {@code getAuthenticationInfo} are {@code private} and {@code final}
 * respectively, replacing the matcher is the only viable fix without forking Shiro.</p>
 *
 * @see org.apache.shiro.realm.AuthenticatingRealm#getAuthenticationInfo
 */
public class ServiceValidatedCredentialsMatcher implements CredentialsMatcher {
    /**
     * Marker that realms set as credentials to signal they have already validated them.
     */
    public static final Object AUTHENTICATED = new Object() {
        @Override
        public String toString() {
            return "ServiceValidatedCredentialsMatcher.AUTHENTICATED";
        }
    };

    @Override
    public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) {
        return info.getCredentials() == AUTHENTICATED;
    }
}

